generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  password  String
  name      String?
  birthDate DateTime?

  ageVerified Boolean?

  emailVerified Boolean @default(false)
  emailVerificationToken String?
  emailVerificationCode String?
  emailVerificationExpires DateTime?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  // Admin & Moderation
  role        UserRole  @default(USER)
  isBanned    Boolean   @default(false)
  banReason   String?
  bannedAt    DateTime?
  bannedBy    String?
  warningCount Int      @default(0)
  lastLoginAt DateTime?
  lastLoginIp String?

  ownedRooms   Room[]   @relation("RoomHost")
  messages     Message[] @relation("MessageSender")
  receivedMessages Message[] @relation("MessageReceiver")
  books        Book[]
  participants Participant[]
  moderators   Moderator[]
  interactions Interaction[]
  bookPosts    BookPost[]

  // Gamification & Social
  points      Int       @default(0)
  level       Int       @default(1)
  badges      Badge[]   @relation("UserBadges")
  followedBy  Follows[] @relation("following")
  following   Follows[] @relation("follower")
  activity    Activity[]
  readingList ReadingList[]
  profileComments ProfileComment[]
  profileVisits    ProfileVisit[] @relation("ProfileVisits")
  receivedProfileVisits ProfileVisit[] @relation("ProfileVisitors")
  sentProfileComments ProfileComment[] @relation("CommentAuthor")
  reports     Report[]  @relation("ReportedUser")
  reportsMade Report[]  @relation("ReportingUser")
  sentFriendRequests FriendRequest[] @relation("RequestSender")
  receivedFriendRequests FriendRequest[] @relation("RequestReceiver")

  // BookFriendSpace-style Profile Customization
  bio              String?   @db.Text
  avatarUrl        String?
  profileTheme     Json?     // { primaryColor, secondaryColor, backgroundColor, textColor, fontFamily, layout }
  profileSong      String?   // URL to audio file
  profileSongTitle String?   // Display name for the song
  profileBackground String?  // URL to background image
  customCSS        String?   @db.Text
  profileViews     Int       @default(0)
  
  // Extended Profile Features
  displayName      String?   // Custom display name
  location         String?   // User location
  website          String?   // Personal website
  socialLinks      Json?     // { twitter, instagram, github, linkedin, etc }
  interests        String[]   @default([]) // User interests/tags
  statusMessage    String?   // Current status/mood
  profileLayout   String?   @default("default") // default, creative, minimalist, neon
  isProfilePublic  Boolean  @default(true) // Profile visibility
  
  // Top Friends (BookFriendSpace style - ordered list of friend IDs)
  topFriends       String[]  @default([])

  // Social Media Features
  stories          Story[]
  storyViews       StoryView[] @relation("StoryViews")
  storyReactions   StoryReaction[] @relation("StoryReactions")
  posts            Post[]
  postLikes        PostLike[] @relation("PostLikes")
  postComments     PostComment[] @relation("PostComments")
  postShares       PostShare[] @relation("PostShares")
  postBookmarks    PostBookmark[] @relation("PostBookmarks")
  notificationsReceived Notification[] @relation("NotificationsReceived")
  notificationsSent     Notification[] @relation("NotificationsSent")
  blockedUsers     UserBlock[] @relation("BlockedUsers")
  blockedByUsers   UserBlock[] @relation("BlockedByUsers")
}

model ReadingList {
  id        String        @id @default(uuid())
  userId    String
  user      User          @relation(fields: [userId], references: [id])
  bookId    String?       // Optional link to uploaded book
  googleId  String        // ID from Google Books API
  title     String
  author    String?
  coverUrl  String?
  status    ReadingStatus @default(WANT_TO_READ)
  rating    Int?
  review    String?
  startDate DateTime?
  finishDate DateTime?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@unique([userId, googleId])
}

enum ReadingStatus {
  WANT_TO_READ
  READING
  FINISHED
  ABANDONED
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
  ELITE_ADMIN
}

model Follows {
  followerId  String
  followingId String
  follower    User @relation("follower", fields: [followerId], references: [id])
  following   User @relation("following", fields: [followingId], references: [id])
  assignedAt  DateTime @default(now())

  @@id([followerId, followingId])
}

model FriendRequest {
  id         String   @id @default(uuid())
  senderId   String
  sender     User     @relation("RequestSender", fields: [senderId], references: [id])
  receiverId String
  receiver   User     @relation("RequestReceiver", fields: [receiverId], references: [id])
  status     FriendRequestStatus @default(PENDING)
  message    String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([senderId, receiverId])
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model Badge {
  id          String   @id @default(uuid())
  name        String   @unique
  description String
  iconUrl     String
  users       User[]   @relation("UserBadges")
  createdAt   DateTime @default(now())
}

model Activity {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String   // "READ_BOOK", "JOIN_ROOM", "CREATE_ROOM", "EARN_BADGE", "FOLLOW_USER", "UNFOLLOW_USER", "CREATE_POST", "LIKE_POST", "COMMENT_POST", "SEND_FRIEND_REQUEST", "ACCEPT_FRIEND_REQUEST", "DECLINE_FRIEND_REQUEST", "FRIEND_REQUEST_ACCEPTED"
  details   String?
  createdAt DateTime @default(now())
}

model Interaction {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  roomId    String
  room      Room     @relation(fields: [roomId], references: [id])
  genreId   String?
  genre     Genre?   @relation(fields: [genreId], references: [id])
  createdAt DateTime @default(now())
}

model Room {
  id          String    @id @default(uuid())
  name        String
  description String?
  hostId      String
  host        User      @relation("RoomHost", fields: [hostId], references: [id])
  genreId     String?
  genre       Genre?    @relation(fields: [genreId], references: [id])
  isLive      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  messages     Message[]
  books        Book[]
  participants Participant[]
  moderators   Moderator[]
  transcripts  Transcript[]
  recap        Recap?
  interactions Interaction[]
}

model Transcript {
  id        String   @id @default(uuid())
  text      String
  startTime DateTime
  endTime   DateTime?
  roomId    String
  room      Room     @relation(fields: [roomId], references: [id])
}

model Recap {
  id        String   @id @default(uuid())
  summary   String
  highlights String[] // Array of quotes or key points
  roomId    String   @unique
  room      Room     @relation(fields: [roomId], references: [id])
  createdAt DateTime @default(now())
}

model Genre {

  id          String   @id @default(uuid())

  name        String   @unique



  description String?

  rooms       Room[]

  interactions Interaction[]

}

model Participant {
  id       String   @id @default(uuid())
  userId   String
  roomId   String
  joinedAt DateTime @default(now())
  room     Room     @relation(fields: [roomId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@unique([userId, roomId])
}

model Moderator {
  id         String   @id @default(uuid())
  userId     String
  roomId     String
  assignedAt DateTime @default(now())
  room       Room     @relation(fields: [roomId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, roomId])
}

model Book {
  id          String   @id @default(uuid())
  title       String
  author      String?
  fileUrl     String?
  fileType    String?
  coverUrl    String?
  description String?
  isbn        String?
  googleId    String?
  ownerId     String
  roomId      String?
  content     String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  owner       User     @relation(fields: [ownerId], references: [id])
  room        Room?    @relation(fields: [roomId], references: [id])
}

model ProfileComment {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  authorId  String   // ID of user who wrote the comment
  author    User     @relation("CommentAuthor", fields: [authorId], references: [id])
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([authorId])
}

model ProfileVisit {
  id        String   @id @default(uuid())
  profileId String
  profile   User     @relation("ProfileVisits", fields: [profileId], references: [id])
  visitorId String
  visitor   User     @relation("ProfileVisitors", fields: [visitorId], references: [id])
  createdAt DateTime @default(now())

  @@index([profileId])
  @@index([visitorId])
}

model Message {
  id        String   @id @default(uuid())
  text      String
  senderId  String
  roomId    String?
  receiverId String?
  readAt    DateTime?
  createdAt DateTime @default(now())
  room      Room?    @relation(fields: [roomId], references: [id])
  sender    User     @relation("MessageSender", fields: [senderId], references: [id])
  receiver  User?    @relation("MessageReceiver", fields: [receiverId], references: [id])
}

// Book Posts - Users can share books they've written
model BookPost {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  title       String
  description String   @db.Text
  coverUrl    String?
  purchaseUrl String?  // Link to buy the book
  previewUrl  String?  // Link to preview/read
  genre       String?
  publishedDate DateTime?
  likes       Int      @default(0)
  shares      Int      @default(0)
  isPinned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// User Reports for moderation
model Report {
  id          String       @id @default(uuid())
  reporterId  String
  reporter    User         @relation("ReportingUser", fields: [reporterId], references: [id])
  reportedId  String
  reported    User         @relation("ReportedUser", fields: [reportedId], references: [id])
  reason      String
  details     String?      @db.Text
  status      ReportStatus @default(PENDING)
  resolvedBy  String?
  resolvedAt  DateTime?
  resolution  String?
  createdAt   DateTime     @default(now())
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

// Admin Activity Log
model AdminLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String   // BAN_USER, UNBAN_USER, DELETE_POST, etc.
  targetId  String?  // ID of affected user/content
  details   String?  @db.Text
  ipAddress String?
  createdAt DateTime @default(now())
}

// Site Analytics
model Analytics {
  id            String   @id @default(uuid())
  date          DateTime @default(now()) @db.Date
  totalUsers    Int      @default(0)
  activeUsers   Int      @default(0)
  newUsers      Int      @default(0)
  totalRooms    Int      @default(0)
  activeRooms   Int      @default(0)
  totalMessages Int      @default(0)
  totalBooks    Int      @default(0)
  pageViews     Int      @default(0)

  @@unique([date])
}

// ============================================
// SOCIAL MEDIA FEATURES
// ============================================

// Stories - Ephemeral content that expires after 24 hours
model Story {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mediaUrl    String   // Image or video URL
  mediaType   String   @default("image") // "image" or "video"
  caption     String?
  backgroundColor String? // For text-only stories
  textContent String?  // For text overlay or text-only stories
  duration    Int      @default(5) // Seconds to display (for video or auto-advance)
  views       StoryView[]
  reactions   StoryReaction[]
  expiresAt   DateTime // Auto-calculated to 24 hours from creation
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model StoryView {
  id        String   @id @default(uuid())
  storyId   String
  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  viewerId  String
  viewer    User     @relation("StoryViews", fields: [viewerId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([storyId, viewerId])
}

model StoryReaction {
  id        String   @id @default(uuid())
  storyId   String
  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("StoryReactions", fields: [userId], references: [id], onDelete: Cascade)
  emoji     String   // Emoji reaction
  createdAt DateTime @default(now())

  @@unique([storyId, userId])
}

// Posts - General social media posts
model Post {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content     String   @db.Text
  mediaUrls   String[] @default([]) // Array of image/video URLs
  mediaTypes  String[] @default([]) // Corresponding types for each media
  hashtags    String[] @default([])
  mentions    String[] @default([]) // User IDs mentioned
  visibility  PostVisibility @default(PUBLIC)
  isEdited    Boolean  @default(false)
  editedAt    DateTime?
  isPinned    Boolean  @default(false)
  likes       PostLike[]
  comments    PostComment[]
  shares      PostShare[]
  bookmarks   PostBookmark[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

enum PostVisibility {
  PUBLIC
  FOLLOWERS_ONLY
  PRIVATE
}

model PostLike {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostLikes", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([postId, userId])
}

model PostComment {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostComments", fields: [userId], references: [id], onDelete: Cascade)
  content   String   @db.Text
  parentId  String?  // For nested replies
  parent    PostComment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   PostComment[] @relation("CommentReplies")
  likes     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([parentId])
}

model PostShare {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostShares", fields: [userId], references: [id], onDelete: Cascade)
  comment   String?  // Optional quote/comment with share
  createdAt DateTime @default(now())

  @@index([postId])
  @@index([userId])
}

model PostBookmark {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostBookmarks", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([postId, userId])
}

// Notifications - Centralized notification system
model Notification {
  id          String   @id @default(uuid())
  userId      String   // User who receives the notification
  user        User     @relation("NotificationsReceived", fields: [userId], references: [id], onDelete: Cascade)
  actorId     String?  // User who triggered the notification
  actor       User?    @relation("NotificationsSent", fields: [actorId], references: [id], onDelete: Cascade)
  type        NotificationType
  title       String
  body        String
  data        Json?    // Additional data (postId, storyId, etc.)
  isRead      Boolean  @default(false)
  readAt      DateTime?
  createdAt   DateTime @default(now())

  @@index([userId, isRead])
  @@index([createdAt])
}

enum NotificationType {
  FOLLOW
  LIKE
  COMMENT
  MENTION
  SHARE
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  STORY_VIEW
  STORY_REACTION
  DIRECT_MESSAGE
  ROOM_INVITE
  BADGE_EARNED
  SYSTEM
}

// Hashtag tracking for discovery
model Hashtag {
  id        String   @id @default(uuid())
  name      String   @unique
  postCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postCount])
}

// User blocks for content moderation
model UserBlock {
  id          String   @id @default(uuid())
  blockerId   String
  blocker     User     @relation("BlockedUsers", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedId   String
  blocked     User     @relation("BlockedByUsers", fields: [blockedId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([blockerId, blockedId])
}
