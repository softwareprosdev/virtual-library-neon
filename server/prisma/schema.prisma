generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  password  String
  name      String?
  birthDate DateTime?

  ageVerified Boolean?

  emailVerified            Boolean   @default(false)
  emailVerificationToken   String?
  emailVerificationCode    String?
  emailVerificationExpires DateTime?
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // Admin & Moderation
  role         UserRole  @default(USER)
  isBanned     Boolean   @default(false)
  banReason    String?
  bannedAt     DateTime?
  bannedBy     String?
  warningCount Int       @default(0)
  lastLoginAt  DateTime?
  lastLoginIp  String?

  ownedRooms       Room[]        @relation("RoomHost")
  messages         Message[]     @relation("MessageSender")
  receivedMessages Message[]     @relation("MessageReceiver")
  books            Book[]
  participants     Participant[]
  moderators       Moderator[]
  interactions     Interaction[]
  bookPosts        BookPost[]

  // Gamification & Social
  points                 Int              @default(0)
  level                  Int              @default(1)
  badges                 Badge[]          @relation("UserBadges")
  followedBy             Follows[]        @relation("following")
  following              Follows[]        @relation("follower")
  activity               Activity[]
  readingList            ReadingList[]
  profileComments        ProfileComment[]
  profileVisits          ProfileVisit[]   @relation("ProfileVisits")
  receivedProfileVisits  ProfileVisit[]   @relation("ProfileVisitors")
  sentProfileComments    ProfileComment[] @relation("CommentAuthor")
  reports                Report[]         @relation("ReportedUser")
  reportsMade            Report[]         @relation("ReportingUser")
  sentFriendRequests     FriendRequest[]  @relation("RequestSender")
  receivedFriendRequests FriendRequest[]  @relation("RequestReceiver")

  // BookFriendSpace-style Profile Customization
  bio               String? @db.Text
  avatarUrl         String?
  profileTheme      Json? // { primaryColor, secondaryColor, backgroundColor, textColor, fontFamily, layout }
  profileSong       String? // URL to audio file
  profileSongTitle  String? // Display name for the song
  profileBackground String? // URL to background image
  customCSS         String? @db.Text
  profileViews      Int     @default(0)

  // Extended Profile Features
  displayName     String? // Custom display name
  location        String? // User location
  website         String? // Personal website
  socialLinks     Json? // { twitter, instagram, github, linkedin, etc }
  interests       String[] @default([]) // User interests/tags
  statusMessage   String? // Current status/mood
  profileLayout   String?  @default("default") // default, creative, minimalist, neon
  isProfilePublic Boolean  @default(true) // Profile visibility

  // Top Friends (BookFriendSpace style - ordered list of friend IDs)
  topFriends String[] @default([])

  // Social Media Features
  stories               Story[]
  storyViews            StoryView[]     @relation("StoryViews")
  storyReactions        StoryReaction[] @relation("StoryReactions")
  posts                 Post[]
  postLikes             PostLike[]      @relation("PostLikes")
  postComments          PostComment[]   @relation("PostComments")
  postShares            PostShare[]     @relation("PostShares")
  postBookmarks         PostBookmark[]  @relation("PostBookmarks")
  notificationsReceived Notification[]  @relation("NotificationsReceived")
  notificationsSent     Notification[]  @relation("NotificationsSent")
  blockedUsers          UserBlock[]     @relation("BlockedUsers")
  blockedByUsers        UserBlock[]     @relation("BlockedByUsers")

  // Marketplace
  listings              MarketplaceListing[] @relation("UserListings")
  savedListings         MarketplaceSave[]    @relation("UserSavedListings")

  // Short-form Video (TikTok-style)
  videos                Video[]              @relation("UserVideos")
  videoLikes            VideoLike[]          @relation("VideoLikes")
  videoComments         VideoComment[]       @relation("VideoComments")
  videoShares           VideoShare[]         @relation("VideoShares")
  videoBookmarks        VideoBookmark[]      @relation("VideoBookmarks")
  userInterests         UserInterest[]
}

model ReadingList {
  id         String        @id @default(uuid())
  userId     String
  user       User          @relation(fields: [userId], references: [id])
  bookId     String? // Optional link to uploaded book
  googleId   String // ID from Google Books API
  title      String
  author     String?
  coverUrl   String?
  status     ReadingStatus @default(WANT_TO_READ)
  rating     Int?
  review     String?
  startDate  DateTime?
  finishDate DateTime?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@unique([userId, googleId])
}

enum ReadingStatus {
  WANT_TO_READ
  READING
  FINISHED
  ABANDONED
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
  ELITE_ADMIN
}

model Follows {
  followerId  String
  followingId String
  follower    User     @relation("follower", fields: [followerId], references: [id])
  following   User     @relation("following", fields: [followingId], references: [id])
  assignedAt  DateTime @default(now())

  @@id([followerId, followingId])
}

model FriendRequest {
  id         String              @id @default(uuid())
  senderId   String
  sender     User                @relation("RequestSender", fields: [senderId], references: [id])
  receiverId String
  receiver   User                @relation("RequestReceiver", fields: [receiverId], references: [id])
  status     FriendRequestStatus @default(PENDING)
  message    String?
  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt

  @@unique([senderId, receiverId])
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model Badge {
  id          String   @id @default(uuid())
  name        String   @unique
  description String
  iconUrl     String
  users       User[]   @relation("UserBadges")
  createdAt   DateTime @default(now())
}

model Activity {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String // "READ_BOOK", "JOIN_ROOM", "CREATE_ROOM", "EARN_BADGE", "FOLLOW_USER", "UNFOLLOW_USER", "CREATE_POST", "LIKE_POST", "COMMENT_POST", "SEND_FRIEND_REQUEST", "ACCEPT_FRIEND_REQUEST", "DECLINE_FRIEND_REQUEST", "FRIEND_REQUEST_ACCEPTED"
  details   String?
  createdAt DateTime @default(now())
}

model Interaction {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  roomId    String
  room      Room     @relation(fields: [roomId], references: [id])
  genreId   String?
  genre     Genre?   @relation(fields: [genreId], references: [id])
  createdAt DateTime @default(now())
}

model Room {
  id          String   @id @default(uuid())
  name        String
  description String?
  hostId      String
  host        User     @relation("RoomHost", fields: [hostId], references: [id])
  genreId     String?
  genre       Genre?   @relation(fields: [genreId], references: [id])
  isLive      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  messages     Message[]
  books        Book[]
  participants Participant[]
  moderators   Moderator[]
  transcripts  Transcript[]
  recap        Recap?
  interactions Interaction[]
}

model Transcript {
  id        String    @id @default(uuid())
  text      String
  startTime DateTime
  endTime   DateTime?
  roomId    String
  room      Room      @relation(fields: [roomId], references: [id])
}

model Recap {
  id         String   @id @default(uuid())
  summary    String
  highlights String[] // Array of quotes or key points
  roomId     String   @unique
  room       Room     @relation(fields: [roomId], references: [id])
  createdAt  DateTime @default(now())
}

model Genre {
  id String @id @default(uuid())

  name String @unique

  description String?

  rooms Room[]

  interactions Interaction[]
}

model Participant {
  id       String   @id @default(uuid())
  userId   String
  roomId   String
  joinedAt DateTime @default(now())
  room     Room     @relation(fields: [roomId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@unique([userId, roomId])
}

model Moderator {
  id         String   @id @default(uuid())
  userId     String
  roomId     String
  assignedAt DateTime @default(now())
  room       Room     @relation(fields: [roomId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, roomId])
}

model Book {
  id          String   @id @default(uuid())
  title       String
  author      String?
  fileUrl     String?
  fileType    String?
  coverUrl    String?
  description String?
  isbn        String?
  googleId    String?
  ownerId     String
  roomId      String?
  content     String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  owner       User     @relation(fields: [ownerId], references: [id])
  room        Room?    @relation(fields: [roomId], references: [id])
}

model ProfileComment {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  authorId  String // ID of user who wrote the comment
  author    User     @relation("CommentAuthor", fields: [authorId], references: [id])
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([authorId])
}

model ProfileVisit {
  id        String   @id @default(uuid())
  profileId String
  profile   User     @relation("ProfileVisits", fields: [profileId], references: [id])
  visitorId String
  visitor   User     @relation("ProfileVisitors", fields: [visitorId], references: [id])
  createdAt DateTime @default(now())

  @@index([profileId])
  @@index([visitorId])
}

model Message {
  id         String    @id @default(uuid())
  text       String
  senderId   String
  roomId     String?
  receiverId String?
  readAt     DateTime?
  createdAt  DateTime  @default(now())
  room       Room?     @relation(fields: [roomId], references: [id])
  sender     User      @relation("MessageSender", fields: [senderId], references: [id])
  receiver   User?     @relation("MessageReceiver", fields: [receiverId], references: [id])
}

// Book Posts - Users can share books they've written
model BookPost {
  id            String    @id @default(uuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  title         String
  description   String    @db.Text
  coverUrl      String?
  purchaseUrl   String? // Link to buy the book
  previewUrl    String? // Link to preview/read
  genre         String?
  publishedDate DateTime?
  likes         Int       @default(0)
  shares        Int       @default(0)
  isPinned      Boolean   @default(false)
  
  // Amazon and affiliate marketing fields
  asin          String?   // Amazon Standard Identification Number
  isbn          String?   // ISBN for book identification
  author        String?   // Author name
  price         Decimal?  // Current price
  currency      String?   @default("USD")
  platform      String?   @default("amazon") // amazon, barnesandnoble, etc
  isAuthorOwn   Boolean   @default(false) // User is the author of this book
  affiliateUrl  String?   // Final affiliate URL with tracking
  clickCount    Int       @default(0) // Track affiliate link clicks
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// User Reports for moderation
model Report {
  id         String       @id @default(uuid())
  reporterId String
  reporter   User         @relation("ReportingUser", fields: [reporterId], references: [id])
  reportedId String
  reported   User         @relation("ReportedUser", fields: [reportedId], references: [id])
  reason     String
  details    String?      @db.Text
  status     ReportStatus @default(PENDING)
  resolvedBy String?
  resolvedAt DateTime?
  resolution String?
  createdAt  DateTime     @default(now())
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

// Admin Activity Log
model AdminLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String // BAN_USER, UNBAN_USER, DELETE_POST, etc.
  targetId  String? // ID of affected user/content
  details   String?  @db.Text
  ipAddress String?
  createdAt DateTime @default(now())
}

// Site Analytics
model Analytics {
  id            String   @id @default(uuid())
  date          DateTime @default(now()) @db.Date
  totalUsers    Int      @default(0)
  activeUsers   Int      @default(0)
  newUsers      Int      @default(0)
  totalRooms    Int      @default(0)
  activeRooms   Int      @default(0)
  totalMessages Int      @default(0)
  totalBooks    Int      @default(0)
  pageViews     Int      @default(0)

  @@unique([date])
}

// ============================================
// SOCIAL MEDIA FEATURES
// ============================================

// Stories - Ephemeral content that expires after 24 hours
model Story {
  id              String          @id @default(uuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  mediaUrl        String // Image or video URL
  mediaType       String          @default("image") // "image" or "video"
  caption         String?
  backgroundColor String? // For text-only stories
  textContent     String? // For text overlay or text-only stories
  duration        Int             @default(5) // Seconds to display (for video or auto-advance)
  views           StoryView[]
  reactions       StoryReaction[]
  expiresAt       DateTime // Auto-calculated to 24 hours from creation
  createdAt       DateTime        @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model StoryView {
  id        String   @id @default(uuid())
  storyId   String
  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  viewerId  String
  viewer    User     @relation("StoryViews", fields: [viewerId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([storyId, viewerId])
}

model StoryReaction {
  id        String   @id @default(uuid())
  storyId   String
  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("StoryReactions", fields: [userId], references: [id], onDelete: Cascade)
  emoji     String // Emoji reaction
  createdAt DateTime @default(now())

  @@unique([storyId, userId])
}

// Posts - General social media posts
model Post {
  id         String         @id @default(uuid())
  userId     String
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  content    String         @db.Text
  mediaUrls  String[]       @default([]) // Array of image/video URLs
  mediaTypes String[]       @default([]) // Corresponding types for each media
  hashtags   String[]       @default([])
  mentions   String[]       @default([]) // User IDs mentioned
  visibility PostVisibility @default(PUBLIC)
  isEdited   Boolean        @default(false)
  editedAt   DateTime?
  isPinned   Boolean        @default(false)
  likes      PostLike[]
  comments   PostComment[]
  shares     PostShare[]
  bookmarks  PostBookmark[]
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@index([userId])
  @@index([createdAt])
}

enum PostVisibility {
  PUBLIC
  FOLLOWERS_ONLY
  PRIVATE
}

model PostLike {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostLikes", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([postId, userId])
}

model PostComment {
  id        String        @id @default(uuid())
  postId    String
  post      Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User          @relation("PostComments", fields: [userId], references: [id], onDelete: Cascade)
  content   String        @db.Text
  parentId  String? // For nested replies
  parent    PostComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   PostComment[] @relation("CommentReplies")
  likes     Int           @default(0)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@index([postId])
  @@index([parentId])
}

model PostShare {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostShares", fields: [userId], references: [id], onDelete: Cascade)
  comment   String? // Optional quote/comment with share
  createdAt DateTime @default(now())

  @@index([postId])
  @@index([userId])
}

model PostBookmark {
  id        String   @id @default(uuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostBookmarks", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([postId, userId])
}

// Notifications - Centralized notification system
model Notification {
  id        String           @id @default(uuid())
  userId    String // User who receives the notification
  user      User             @relation("NotificationsReceived", fields: [userId], references: [id], onDelete: Cascade)
  actorId   String? // User who triggered the notification
  actor     User?            @relation("NotificationsSent", fields: [actorId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  body      String
  data      Json? // Additional data (postId, storyId, etc.)
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@index([userId, isRead])
  @@index([createdAt])
}

enum NotificationType {
  FOLLOW
  LIKE
  COMMENT
  MENTION
  SHARE
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  STORY_VIEW
  STORY_REACTION
  DIRECT_MESSAGE
  ROOM_INVITE
  BADGE_EARNED
  SYSTEM
  // Video notifications
  VIDEO_LIKE
  VIDEO_COMMENT
  VIDEO_MENTION
  VIDEO_DUET
  VIDEO_STITCH
}

// Hashtag tracking for discovery
model Hashtag {
  id        String   @id @default(uuid())
  name      String   @unique
  postCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postCount])
}

// User blocks for content moderation
model UserBlock {
  id        String   @id @default(uuid())
  blockerId String
  blocker   User     @relation("BlockedUsers", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedId String
  blocked   User     @relation("BlockedByUsers", fields: [blockedId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([blockerId, blockedId])
}

// ============================================
// MARKETPLACE
// ============================================

model MarketplaceListing {
  id          String            @id @default(uuid())
  sellerId    String
  seller      User              @relation("UserListings", fields: [sellerId], references: [id], onDelete: Cascade)
  title       String
  description String            @db.Text
  price       Float
  currency    String            @default("USD")
  condition   ListingCondition  @default(GOOD)
  category    String
  images      String[]          @default([])
  location    String?
  status      ListingStatus     @default(ACTIVE)
  viewCount   Int               @default(0)
  savedBy     MarketplaceSave[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([sellerId])
  @@index([category])
  @@index([status])
  @@index([createdAt])
}

enum ListingCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  POOR
}

enum ListingStatus {
  ACTIVE
  SOLD
  RESERVED
  DELETED
}

model MarketplaceSave {
  id        String             @id @default(uuid())
  userId    String
  user      User               @relation("UserSavedListings", fields: [userId], references: [id], onDelete: Cascade)
  listingId String
  listing   MarketplaceListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  createdAt DateTime           @default(now())

  @@unique([userId, listingId])
}

// ============================================
// SHORT-FORM VIDEO (TikTok-Style)
// ============================================

// Video content model
model Video {
  id              String                @id @default(uuid())
  userId          String
  user            User                  @relation("UserVideos", fields: [userId], references: [id], onDelete: Cascade)

  // Video metadata
  videoUrl        String                // Processed video URL (S3)
  thumbnailUrl    String?               // Auto-generated thumbnail
  duration        Int                   // Duration in seconds
  aspectRatio     String                @default("9:16") // 9:16, 16:9, 1:1
  width           Int?
  height          Int?

  // Content
  caption         String?               @db.Text
  hashtags        String[]              @default([])
  mentions        String[]              @default([]) // User IDs mentioned

  // Sound/Music
  soundId         String?
  sound           Sound?                @relation(fields: [soundId], references: [id])
  originalAudio   Boolean               @default(true)

  // Engagement
  likes           VideoLike[]
  comments        VideoComment[]
  shares          VideoShare[]
  bookmarks       VideoBookmark[]
  views           VideoView[]

  // Duet/Stitch collaborative features
  duetSourceId    String?
  duetSource      Video?                @relation("Duets", fields: [duetSourceId], references: [id])
  duets           Video[]               @relation("Duets")
  stitchSourceId  String?
  stitchSource    Video?                @relation("Stitches", fields: [stitchSourceId], references: [id])
  stitches        Video[]               @relation("Stitches")

  // Settings
  visibility      PostVisibility        @default(PUBLIC)
  allowDuet       Boolean               @default(true)
  allowStitch     Boolean               @default(true)
  allowComments   Boolean               @default(true)

  // Processing status
  processingStatus VideoProcessingStatus @default(PENDING)
  processingError  String?

   // Category
   category         VideoCategory         @default(OTHER)

   // FYP Algorithm Data
   categoryScores   Json?                 // ML-generated category scores
   engagementScore  Float                 @default(0)

  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

   @@index([userId])
   @@index([soundId])
   @@index([createdAt])
   @@index([engagementScore])
   @@index([processingStatus])
   @@index([category])
}

enum VideoProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum VideoCategory {
  EDUCATION
  ENTERTAINMENT
  MUSIC
  SPORTS
  FOOD
  TRAVEL
  FASHION
  TECH
  GAMING
  COMEDY
  DIY
  NEWS
  OTHER
}

// Sound/Music model for videos
model Sound {
  id              String    @id @default(uuid())
  title           String
  artistName      String?
  coverUrl        String?
  audioUrl        String
  duration        Int       // Duration in seconds
  isOriginal      Boolean   @default(false)
  originalVideoId String?   // If extracted from a video
  usageCount      Int       @default(0)
  isTrending      Boolean   @default(false)
  videos          Video[]
  createdAt       DateTime  @default(now())

  @@index([usageCount])
  @@index([isTrending])
  @@index([title])
}

model VideoLike {
  id        String   @id @default(uuid())
  videoId   String
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("VideoLikes", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([videoId, userId])
  @@index([videoId])
  @@index([userId])
}

model VideoComment {
  id        String          @id @default(uuid())
  videoId   String
  video     Video           @relation(fields: [videoId], references: [id], onDelete: Cascade)
  userId    String
  user      User            @relation("VideoComments", fields: [userId], references: [id], onDelete: Cascade)
  content   String          @db.Text
  parentId  String?
  parent    VideoComment?   @relation("VideoCommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   VideoComment[]  @relation("VideoCommentReplies")
  likes     Int             @default(0)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([videoId])
  @@index([parentId])
}

model VideoShare {
  id        String   @id @default(uuid())
  videoId   String
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("VideoShares", fields: [userId], references: [id], onDelete: Cascade)
  platform  String?  // twitter, facebook, copy, internal, etc.
  createdAt DateTime @default(now())

  @@index([videoId])
  @@index([userId])
}

model VideoBookmark {
  id        String   @id @default(uuid())
  videoId   String
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("VideoBookmarks", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([videoId, userId])
  @@index([userId])
}

model VideoView {
  id          String    @id @default(uuid())
  videoId     String
  video       Video     @relation(fields: [videoId], references: [id], onDelete: Cascade)
  userId      String?
  viewerIp    String?   // For anonymous views
  watchTime   Int       @default(0) // Seconds watched
  completed   Boolean   @default(false) // Whether video was watched to completion
  createdAt   DateTime  @default(now())

  @@index([videoId])
  @@index([userId])
}

// User interest model for FYP recommendations
model UserInterest {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category  String   // e.g., "comedy", "education", "books", "cooking", "music"
  score     Float    @default(0) // -1 to 1, updated by engagement
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@unique([userId, category])
  @@index([userId])
  @@index([score])
}
